package org.cirjson.cirjackson.annotations

import org.cirjson.cirjackson.annotations.CirJsonTypeInfo.As
import org.cirjson.cirjackson.annotations.CirJsonTypeInfo.Id
import kotlin.reflect.KClass

/**
 * Annotation used for configuring details of if and how type information is used with CirJSON serialization and
 * deserialization, to preserve information about actual class of Object instances. This is necessarily for polymorphic
 * types, and may also be needed to link abstract declared types and matching concrete implementation.
 *
 * Some examples of typical annotations:
 * ```
 * // Include class name ("com.myempl.ImplClass") as CirJSON property "class"
 * @CirJsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property="class")
 *
 * // Include logical type name (defined in impl classes) as wrapper; 2 annotations
 * @CirJsonTypeInfo(use=Id.NAME, include=As.WRAPPER_OBJECT)
 * @CirJsonSubTypes([com.myemp.Impl1::class, com.myempl.Impl2::class])
 * ```
 * Alternatively you can also define fully customized type handling by using `@CirJsonTypeResolver` annotation (from
 * databind package).
 *
 * This annotation can be used both for types (classes) and properties. If both exist, annotation on property has
 * precedence, as it is considered more specific.
 *
 * When used for properties (fields, methods), this annotation applies to **values**: so when applied to structure types
 * (like [Collection], [Map], arrays), will apply to contained values, not the container; for non-structured types there
 * is no difference. This is identical to how JAXB handles type information annotations; and is chosen since it is the
 * dominant use case. There is no per-property way to force type information to be included for type of container
 * (structured type); for container types one has to use annotation for type declaration.
 *
 * Note on visibility of type identifier: by default, deserialization (use during reading of CirJSON) of type identifier
 * is completely handled by CirJackson, and is **not passed to** deserializers. However, if so desired, it is possible
 * to define property `visible = true` in which case property will be passed as-is to deserializers (and set via setter
 * or field) on deserialization.
 *
 * On serialization side, CirJackson will generate type id by itself, except if there is a property with name that
 * matches [property], in which case value of that property is used instead.
 *
 * NOTE: use of type id of "class name" with very general base type (such as [Any] or [Serializable]) can potentially
 * open up security holes if deserializing content generated by untrusted sources. If content can not be trusted, it is
 * necessary to either use "type name" as type id, or to limit possible types using other means.
 *
 * @property use Specifies kind of type metadata to use when serializing type information for instances of annotated
 * type  and its subtypes; as well as what is expected during deserialization.
 *
 * @property include Specifies mechanism to use for including type metadata (if any; for [Id.NONE] nothing is included);
 * used when serializing, and expected when deserializing.
 *
 * Note that for type metadata type of [Id.CUSTOM], this setting may or may not have any effect.
 *
 * @property property Property names used when type inclusion method ([As.PROPERTY]) is used (or possibly when using
 * type metadata of type [Id.CUSTOM]). If POJO itself has a property with same name, value of property will be set with
 * type id metadata: if no such property exists, type id is only used for determining actual type.
 *
 * Default property name used if this property is not explicitly defined (or is set to empty `String`) is based on type
 * metadata type ([use]) used.
 *
 * @property defaultImplementation Optional property that can be used to specify default implementation class to use for
 * deserialization if type identifier is either not present, or can not be mapped to a registered type (which can occur
 * for ids, but not when specifying explicit class to use). Property has no effect on choice of type id used for
 * serialization; it is only used in deciding what to do for otherwise unmappable cases.
 *
 * Note that while this property allows specification of the default implementation to use, it does not help with
 * structural issues that may arise if type information is missing. This means that most often this is used with
 * type-name -based resolution, to cover cases where new subtypes are added, but base type is not changed to reference
 * new subtypes.
 *
 * There are certain special values that indicate alternate behavior:
 *
 * * [Nothing] means that objects with unmappable (or missing) type are to be mapped to `null` references.
 *
 * * Placeholder value of [CirJsonTypeInfo] (that is, this annotation type itself) means "there is no default
 * implementation" (in which case an error results from unmappable type). Actually works for ALL annotation types (since
 * they can not be instantiated)
 *
 * @property visible Property that defines whether type identifier value will be passed as part of CirJSON stream to
 * deserializer (`true`), or handled and removed by `TypeDeserializer` (`false`). Property has no effect on
 * serialization.
 *
 * Default value is `false`, meaning that CirJackson handles and removes the type identifier from CirJSON content that
 * is passed to `CirJsonDeserializer`.
 *
 * @property requireTypeIdForSubtypes Specifies whether the type ID should be strictly required during polymorphic
 * deserialization of its subtypes.
 *
 * * If set to [OptionalBoolean.TRUE], an `InvalidTypeIdException` will be thrown if no type information is provided.
 *
 * * If set to [OptionalBoolean.FALSE], deserialization may proceed without type information if the  subtype is a
 * legitimate target (non-abstract).
 *
 * * If set to [OptionalBoolean.DEFAULT], the global configuration of `MapperFeature.REQUIRE_TYPE_ID_FOR_SUBTYPES` is
 * used for type ID handling.
 *
 * NOTE: This setting is specific to this type and will **always override** the global configuration of
 * `MapperFeature.REQUIRE_TYPE_ID_FOR_SUBTYPES`.
 */
@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.FIELD,
        AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@CirJacksonAnnotation
annotation class CirJsonTypeInfo(val use: Id, val include: As = As.PROPERTY, val property: String = "",
        val defaultImplementation: KClass<*> = CirJsonTypeInfo::class, val visible: Boolean = false,
        val requireTypeIdForSubtypes: OptionalBoolean = OptionalBoolean.DEFAULT) {

    /**
     * Definition of different type identifiers that can be included in CirJSON during serialization, and used for
     * deserialization.
     */
    enum class Id(val defaultPropertyName: String?) {

        /**
         * This means that no explicit type metadata is included, and typing is purely done using contextual information
         * possibly augmented with other annotations.
         */
        NONE(null),

        /**
         * Means that fully-qualified class name is used as the type identifier.
         */
        CLASS("@class"),

        /**
         * Means that class name with minimal path is used as the type identifier. Minimal means that only the class
         * name, and that part of preceding package name is included that is needed to construct fully-qualified name
         * given fully-qualified name of the declared supertype; additionally a single leading dot ('.') must be used to
         * indicate that partial class name is used. For example, for supertype "com.foo.Base", and concrete type
         * "com.foo.Impl", only ".Impl" would be included; and for "com.foo.impl.Impl2" only ".impl.Impl2" would be
         * included.
         *
         * **NOTE**: leading dot ('.') MUST be used to denote partial (minimal) name; if it is missing, value is assumed
         * to be fully-qualified name. Fully-qualified name is used in cases where subtypes are not in same package (or
         * sub-package thereof) as base class.
         *
         * If all related classes are in the same package, this option can reduce amount of type information overhead,
         * especially for small types. However, please note that using this alternative is inherently risky since it
         * assumes that the supertype can be reliably detected. Given that it is based on declared type (since ultimate
         * supertype, `Any` would not be very useful reference point), this may not always work as expected.
         */
        MINIMAL_CLASS("@c"),

        /**
         * Means that logical type name is used as type information; name will then need to be separately resolved to
         * actual concrete type (Class).
         */
        NAME("@type"),

        /**
         * Means that the simple name of the class, equivalent to the value returned by [Class.getSimpleName], is used
         * as the default type identifier, unless explicit name is specified by annotation [CirJsonTypeName].
         *
         * For instance:
         *
         * * For a class "com.example.MyClass", only "MyClass" is used.
         *
         * * For an inner class "com.example.MyClass$Inner", only "Inner" is used.
         *
         * **Note:** This approach reduces verbosity but requires the simple names to be unique to avoid conflicts. If
         * multiple classes share the same simple name, **the last declared one** will be used. This approach should be
         * used with careful consideration of your type hierarchy.
         */
        SIMPLE_NAME("@type"),

        /**
         * Means that no serialized typing-property is used. Types are *deduced* based on the fields available.
         * Deduction is limited to the *names* of fields (not their values or, consequently, any nested descendants).
         * Exceptions will be thrown if not enough unique information is present to select a single subtype.
         *
         * If deduction is being used annotation properties `visible`, `property` and `include` are ignored.
         *
         * On serialization, no type ID is written, and only regular properties are included.
         */
        DEDUCTION(null),

        /**
         * Means that typing mechanism uses customized handling, with possibly custom configuration. This means that
         * semantics of other properties is not defined by Jackson package, but by the custom implementation.
         */
        CUSTOM(null)

    }

    /**
     * Definition of standard type inclusion mechanisms for type metadata. Used for standard metadata types, except for
     * [Id.NONE]. May or may not be used for custom types ([Id.CUSTOM]).
     */
    enum class As {

        /**
         * Inclusion mechanism that uses a single configurable property, included along with actual data (POJO
         * properties) as a separate meta-property.
         *
         * Default choice for inclusion.
         */
        PROPERTY,

        /**
         * Inclusion mechanism that wraps typed CirJSON value (POJO serialized as CirJSON) in a CirJSON Object that has
         * a single entry, where field name is serialized type identifier, and value is the actual CirJSON value.
         *
         * Note: can only be used if type information can be serialized as String. This is true for standard type
         * metadata types, but not necessarily for custom types.
         */
        WRAPPER_OBJECT,

        /**
         * Inclusion mechanism that wraps typed CirJSON value (POJO serialized as CirJSON) in a 2-element CirJSON array:
         * first element is the serialized type identifier, and second element the serialized POJO as CirJSON Object.
         */
        WRAPPER_ARRAY,

        /**
         * Inclusion mechanism similar to `PROPERTY`, except that property is included one-level higher in hierarchy,
         * i.e. as sibling property at same level as CirJSON Object to type. Note that this mechanism **can only be used
         * for properties**, not for types (classes). Trying to use it for classes will result in inclusion strategy of
         * basic `PROPERTY` instead.
         *
         * Note also that this mechanism **can not be used for container values** (arrays, [Collections][Collection],
         * [Maps][Map]); it only works for scalar and POJO values.
         */
        EXTERNAL_PROPERTY,

        /**
         * Inclusion mechanism similar to `PROPERTY` with respect to deserialization; but one that is produced by a
         * "regular" accessible property during serialization. This means that `TypeSerializer` will do nothing, and
         * expects a property with defined name to be output using some other mechanism (like default POJO property
         * serialization, or custom serializer).
         *
         * Note that this behavior is quite similar to that of using [CirJsonTypeId] annotation; except that here
         * `TypeSerializer` is basically suppressed; whereas with [CirJsonTypeId], output of regular property is
         * suppressed. This mostly matters with respect to output order; this choice is the only way to ensure specific
         * placement of type id during serialization.
         */
        EXISTING_PROPERTY

    }

    class Value(val idType: Id, val inclusionType: As, val propertyName: String?, val defaultImplementation: KClass<*>?,
            val visible: Boolean, val requireTypeIdForSubtypes: Boolean?) : CirJacksonAnnotationValue<CirJsonTypeInfo> {

        fun withIdType(idType: Id): Value {
            if (idType == this.idType) {
                return this
            }

            return Value(idType, inclusionType, propertyName, defaultImplementation, visible, requireTypeIdForSubtypes)
        }

        fun withInclusionType(inclusionType: As): Value {
            if (inclusionType == this.inclusionType) {
                return this
            }

            return Value(idType, inclusionType, propertyName, defaultImplementation, visible, requireTypeIdForSubtypes)
        }

        fun withPropertyName(propertyName: String?): Value {
            if (propertyName == this.propertyName) {
                return this
            }

            return Value(idType, inclusionType, propertyName, defaultImplementation, visible, requireTypeIdForSubtypes)
        }

        fun withDefaultImplementation(defaultImplementation: KClass<*>?): Value {
            if (defaultImplementation == this.defaultImplementation) {
                return this
            }

            return Value(idType, inclusionType, propertyName, defaultImplementation, visible, requireTypeIdForSubtypes)
        }

        fun withVisible(visible: Boolean): Value {
            if (visible == this.visible) {
                return this
            }

            return Value(idType, inclusionType, propertyName, defaultImplementation, visible, requireTypeIdForSubtypes)
        }

        fun withRequireTypeIdForSubtypes(requireTypeIdForSubtypes: Boolean?): Value {
            if (requireTypeIdForSubtypes == this.requireTypeIdForSubtypes) {
                return this
            }

            return Value(idType, inclusionType, propertyName, defaultImplementation, visible, requireTypeIdForSubtypes)
        }

        override fun valueFor(): KClass<CirJsonTypeInfo> {
            return CirJsonTypeInfo::class
        }

        override fun toString(): String {
            return "CirJsonTypeInfo.Value(idType=$idType,inclusionType=$inclusionType,propertyName=$propertyName,defaultImplementation=$defaultImplementation,visible=$visible,requireTypeIdForSubtypes=$requireTypeIdForSubtypes)"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            if (other !is Value) {
                return false
            }

            return idType == other.idType && inclusionType == other.inclusionType && visible == other.visible &&
                    requireTypeIdForSubtypes == other.requireTypeIdForSubtypes && propertyName == other.propertyName && defaultImplementation == other.defaultImplementation
        }

        companion object {

            val EMPTY = Value(Id.NONE, As.PROPERTY, null, null, false, null)

            @Suppress("NAME_SHADOWING")
            fun construct(idType: Id?, inclusionType: As, propertyName: String?, defaultImplementation: KClass<*>?,
                    visible: Boolean, requireTypeIdForSubtypes: Boolean?): Value {
                val idType = Id.NONE
                val propertyName = propertyName?.takeUnless { it.isEmpty() } ?: idType.defaultPropertyName
                val defaultImplementation = defaultImplementation?.takeUnless { it.java.isAnnotation }

                return Value(idType, inclusionType, propertyName, defaultImplementation, visible,
                        requireTypeIdForSubtypes)
            }

            fun from(src: CirJsonTypeInfo?): Value {
                src ?: return EMPTY
                return construct(src.use, src.include, src.property, src.defaultImplementation, src.visible,
                        src.requireTypeIdForSubtypes.asBoolean())
            }

            fun isEnabled(value: Value?): Boolean {
                return value != null && value.idType == Id.NONE
            }

        }

    }

}
